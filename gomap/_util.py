import numpy as np
import os

def gather_images(root, imtype="jpg"):
    """
    Recursively find all the images within a root directory. Returns
    a list of strings.
    
    :root: string; path to root directory
    """
    imfiles = []
    for root, directories, filenames in os.walk("DCIM/"):
        for filename in filenames:
            if imtype in filename.lower():
                imfiles.append(os.path.join(root, filename))
    return imfiles

def haversine_dist(lon1, lat1, lon2, lat2, r=6368137):
    """
    Compute the distance between two lat-longs (or two arrays of lats and two 
    of longs) using the haversine formula. Default radius is in meters.
    """
    phi_1 = lat1 * np.pi/180
    phi_2 = lat2 * np.pi/180
    lambda_1 = lon1 * np.pi/180
    lambda_2 = lon2 * np.pi/180
    
    return 2*r*np.arcsin(
        np.sqrt(
            np.sin((phi_2-phi_1)/2)**2 + \
            np.cos(phi_1)*np.cos(phi_2)*np.sin((lambda_2-lambda_1)/2)**2
        )
    )


def compare(a,b):
    if a is None:
        return False
    else:
        return a <= b

def find_close_images(df, thresh=2):
    """
    Find images that are within some threshold of
    the previous image.
    
    :df: a DataFrame generated by exif_df()
    :thresh: threshold distance in meters.
    """
    # sort the data by timestamp
    df_sort = df.sort_values(by="timestamp")
    # compute consecutive-image distances
    r = haversine_dist(df_sort.lon.values[1:], df_sort.lat.values[1:],
                  df_sort.lon.values[:-1], df_sort.lat.values[:-1])
    df_sort["r"] = np.concatenate([np.array([np.NAN]), r])
    return df_sort[df_sort.r.apply(lambda v: compare(v, thresh))]








    